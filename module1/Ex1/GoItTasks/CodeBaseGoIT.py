# 1. Write a Python program to sum all the items in a list.
def add_function(numbers_to_add: list):
    total_add_sum = 0
    for num in numbers_to_add:
        total_add_sum += num

    return total_add_sum


print(add_function([1, 2, 3]))
# Done


# Alternative
def add_function(numbers_to_add: list):
    return sum(numbers_to_add)


# 2. Write a Python program to multiply all the items in a list.
def multiplication_function(numbers_to_multi: list):
    total_multi_sum = 1  # always should be 1 becaouse it's multiplication
    for num in numbers_to_multi:
        total_multi_sum *= num
    return total_multi_sum


print(multiplication_function([1, 2, 2, 3]))

# Done
# 3. Write a Python program to get the largest number from a list.


def largest_number_function(numbers: list):
    maximum_number = max(numbers)
    return maximum_number


print(largest_number_function([1, 1111, 2443, 45, 65, 76, 67]))


# Alternative
def largest_number_function(numbers: list):
    return max(numbers)


# Done

# 4. Write a Python program to get the smallest number from a list.


def min_number_in_list(numbers: list):
    for_smallest_number = numbers[0]  # Here we assign the integer type of data
    for num in numbers:  # Num here is also an integer, so can work with two integers
        if num < for_smallest_number:  # if large number needed change the < sign to
            for_smallest_number = num  # assign one integer to another
    return for_smallest_number  # and here we return integer


print(min_number_in_list([1, 1111, 2443, 45, 65, 76, 67]))

# Done
# 5. Створіть програму на Python, яка розраховує суму всіх цілих чисел від 1 до числа, введеного користувачем.
num = int(input("Enter the integer (0 to 100): "))
sum = 0
while num > 0:
    sum += num
    num -= 1

# Done

# 5. Напишіть функцію get_fullname на Python, яка приймає ім'я, прізвище та, опціонально, друге ім'я (або по батькові) та повертає рядок з повним іменем користувача.


def get_fullname(first_name, last_name, middle_name=""):
    if len(middle_name) == 0:
        return f"{first_name} {last_name}"
    else:
        return f"{first_name} {middle_name} {last_name}"


# Done

# 6. Напишіть функцію format_string, яка центрує рядок у рамках заданої довжини length.
"""
Задачі:
1) Створіть функцію format_string, яка приймає два аргументи: string рядок, який потрібно форматувати та length довжина, у межах якої потрібно центрувати рядок.
2) Якщо довжина string більша або дорівнює length, поверніть рядок без змін.
3) Якщо довжина string менша за length, додайте перед рядком пробіли, для того, щоб рядок був центрований у рамках length.
"""


def format_string(string, length):
    if len(string) >= length:
        return string
    else:
        spaces_count = (length - len(string)) // 2
        return f"{' ' * spaces_count}{string}"


# Done

"""
Наступне завдання буде суто теоретичним, і ми потренуємося створювати функції в Python, які можуть приймати довільну кількість позиційних або ключових аргументів.

Задачі:

Створіть функцію first, яка приймає один обов'язковий аргумент size та довільну кількість позиційних аргументів. Функція має повертати суму: size + кількість позиційних аргументів.
Створіть функцію second, яка також приймає один обов'язковий аргумент size та довільну кількість ключових аргументів. Функція має повертати суму: size + кількість ключових аргументів.
В обох функціях використовуйте спеціальні синтаксиси * для позиційних аргументів та ** для ключових аргументів.
Очікуваний результат:

Функції повинні коректно розраховувати суму size та кількості переданих аргументів.
"""


def first(size, *args):
    ar = len(args)
    total_sum_ar = size + ar

    return total_sum_ar


def second(size, **kwargs):
    kw = len(kwargs)
    total_sum_kw = size + kw

    return total_sum_kw


# Done

"""
Ми проводимо розіграш призів серед перших 50 підписників ютуб-каналу. Ми маємо 7 призів для розіграшу. Може виникнути питання, скільки різних списків переможців ми можемо отримати під час розіграшу? Для цього ми будемо використовувати формулу сполучень без повторень

Cnk = n! / ((n - k)! · k!)

де n — це загальна кількість людей (випадків), а k — кількість людей, які отримали призи.

Напишіть функцію number_of_groups, яка приймає параметри n та k, і за допомогою функції factorial повертає нам скільки різних списків переможців ми можемо отримати при розіграші

Задачі:

1.Створіть функцію number_of_groups, яка приймає два аргументи: n - загальна кількість людей та k - кількість переможців.
2.У функції number_of_groups, використовуйте функцію factorial для обчислення факторіалів відповідно до формули сполучень: Cnk = n! / ((n - k)! · k!).
3.Обчислення здійснюється шляхом виклику функції factorial для отримання факторіалів n, n - k та k.
4.Поверніть результат цього обчислення.
"""


def factorial(n):  # функція яка виконує обчислення факторіалу
    if n < 2:  # умова зупинки виклику функції
        return 1
    else:
        return n * factorial(n - 1)  # обчислення факторілу


def number_of_groups(n, k):
    return factorial(n) // (
        (factorial(n - k)) * factorial(k)
    )  # використання рекурсивної функції факторіалу


# Done


# Task: Write a Python program to find the average length of strings in a given list of strings.
def average_rage_of_string(
    words: list,
) -> float:  # assign the types of arguments and expected reults
    total_string_lenght = (
        0  # assign the variable to count the total lenght of string in list
    )
    for elem in words:
        total_string_lenght += len(elem)  # counting the total lenght of strings

    return total_string_lenght / len(
        words
    )  # return the average of all elemnts in list of strings


print(average_rage_of_string(["radar", "level", "python", "noon", "pop"]))
# Done

# Task: Write a Python program to find the longest word in a given list of words.


def the_longest_word(
    words: list,
) -> str:  # define the types of data that function have to accept
    longest_word = ""  # create an empty str to assing value from loop
    for elem in words:
        if len(elem) > len(
            longest_word
        ):  # check if lenght of the previous elemt  bigger then our empty string (here I had to be carful with data type for check "int" should check with "int")
            longest_word = elem  # if True assign str value to our empty string
    return longest_word  # return the biggest string form the list


print(
    the_longest_word(
        [
            "radar",
            "level",
            "python",
            "noon",
            "pop",
            "jfkdskhjgfjkdfgjgfdjgfdklfgdlkgfdlkgfdklgfdkl",
        ]
    )
)

# Done

# Task: Write a Python program to find the longest word in a given list of words. (I added a check for other data types in this function, so now it works only with strings :) )


def the_longest_word(words: list) -> str:
    longest_word = ""
    for elem in words:
        if isinstance(elem, str):
            if len(elem) > len(longest_word):
                longest_word = elem
        else:
            print(f" {elem} is't a string, sorry but we work only with strings :)")
    return longest_word


print(
    the_longest_word(
        [
            123456,
            "radar",
            "level",
            "python",
            "noon",
            "pop",
            "jfkdskhjgfjkdfgjgfdjgfdklfgdlkgfdlkgfdklgfdkl",
        ]
    )
)

# Done

# Task: Write a Python program to find the median of a given list of numbers.


def find_median(numbers):
    numbers.sort()  # Sort the list of numbers
    n = len(numbers)
    if n % 2 == 1:
        # If the length of the list is odd
        return numbers[n // 2]
    else:
        # If the length of the list is even
        mid1 = n // 2
        mid2 = mid1 - 1
        return (numbers[mid1] + numbers[mid2]) / 2


# Example usage
my_numbers = [5, 3, 1, 4, 2]
print("Median of the list:", find_median(my_numbers))

# analyzed

# Define a list 'a' with some duplicate and unique elements
a = [10, 20, 30, 20, 10, 50, 60, 40, 80, 50, 40]

# Create an empty set to store duplicate items and an empty list for unique items
dup_items = set()
uniq_items = []

# Iterate through each element 'x' in the list 'a'
for x in a:
    # Check if the current element 'x' is not already in the set 'dup_items' (it's a duplicate check)
    if x not in dup_items:
        # If 'x' is not a duplicate, add it to the 'uniq_items' list
        uniq_items.append(x)
        # Add 'x' to the 'dup_items' set to mark it as a seen item
        dup_items.add(x)

# Print the set 'dup_items' which now contains the unique elements from the original list 'a'
print(dup_items)

# analyzed

# Task: Implement a function that checks if two lists have the same elements in the same order and return True if they do, otherwise return False.
a = [1, 2, 3]


def same_elemts_check(elements_set_first: list, elements_set_second: list) -> bool:
    if elements_set_first is elements_set_second:
        return True
    else:
        return False


print(same_elemts_check(a, a))
print(same_elemts_check(a, [1, 2, 3]))

# Done

# Task: Write the Python program to remove duplicates from a list to also preserve the original order of elements in the list.


def remove_dublicates(elements: list) -> list:
    dup_items = set()  # here we create a set for duplicates
    new_list = []  # here we create an empty list to store sorted data

    for elem in elements:
        if elem not in dup_items:
            new_list.append(elem)
            dup_items.add(elem)
        else:
            new_list.append(" ")
    return new_list


print(remove_dublicates([10, 20, 30, 20, 10, 50, 60, 40, 80, 50, 40]))

# Done

# Task: Given an array of string (strs), group the anagrams together. (hash-map)
from collections import (
    defaultdict,
)  # we innitializing this to get an empty dictionaries wil already assign values for "keys" so we don't need to create a key evry time to assign a values into the dictionary


def groupAnagrams(strs: list[str]) -> list[str]:
    anagram_map = defaultdict(
        list
    )  # we created a dictionary by using the defauldict to add new keys with values without creating a key each time for new values and the type for value will be list (by default)
    result = []  # an empty array that we will return as a result of function

    for s in strs:  # here we are going trought each word in list
        sorted_s = tuple(
            sorted(s)
        )  # the main idea here is to sort all elements in word in alphabtic oreder and assign it's copy as a key into our dictionary(anagram_map), we convert it into the tuple because list(mutable) data type can't be the key (always have to be immutable) in dictionaries
        anagram_map[sorted_s].append(
            s
        )  # here we added they key to our (anagram map[sorted.s]), and add the word from the (strs) if it's match this key

    for values in anagram_map.values():  # will give us the list of the values
        result.append(
            values
        )  # and for each of this values we are going to append them into our values list and return it

    return result


print(groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))

# analyzed, done with youtube.


# Taks: Write a Python program that takes a list of strings as input and prints each string along with its index in the list.

name_list = ["Alice", "Bob", "Charle", "David", "Emily"]
for i, value in enumerate(name_list):
    print(f"Index is = {i}, value of this index = {value}")

# Done

# Write a Python function called combine_lists that takes two lists of equal length as input and returns a list of tuples where each tuple contains elements from corresponding indices of the input lists.
list1 = [1, 2, 3, 4]
list2 = ["a", "b", "c", "d"]
new_list = []
if len(list1) == len(list2):
    for number, value in zip(list1, list2):
        appendr = (number, value)
        new_list.append(appendr)
else:
    print("lists have not equal lenght")

print(new_list)

# Done
# Перевірка балансу для здійснення покупки
balance = 0.7 + 0.6
print(balance)
if round(balance, 1) == 1.3:  # always use round with float numbers
    print("Enough")
else:
    print("Not Enough")
print(round(balance, 1))

# analyzed
# У результаті виклику методу now() ми отримуємо об'єкт datetime, у якого є ряд корисних атрибутів:
from datetime import datetime

current_datetime = datetime.now()

print(current_datetime.year)
print(current_datetime.month)
print(current_datetime.day)
print(current_datetime.hour)
print(current_datetime.minute)
print(current_datetime.second)
print(current_datetime.microsecond)
print(current_datetime.tzinfo)

# analyzed
# Datetime for homework
from datetime import datetime

# Створення двох об'єктів datetime
datetime1 = datetime(2023, 3, 14, 12, 0)
datetime2 = datetime(2023, 3, 15, 12, 0)

# Порівняння дат
print(datetime1 == datetime2)  # False, тому що дати не однакові
print(datetime1 != datetime2)  # True, тому що дати різні
print(datetime1 < datetime2)  # True, тому що datetime1 передує datetime2
print(datetime1 > datetime2)  # False, тому що datetime1 не наступає за datetime2
# analyzed

# Якщо відняти від одного datetime об'єкту інший, то отримаємо timedelta об'єкт. Він відповідає за відрізок часу між двома датами.
from datetime import datetime

seventh_day_2019 = datetime(year=2019, month=1, day=7, hour=14)
seventh_day_2020 = datetime(year=2020, month=1, day=7, hour=14)

difference = seventh_day_2020 - seventh_day_2019
print(difference)  # 365 days, 0:00:00
print(difference.total_seconds())  # 31536000.0
print(type(difference))
print(type(seventh_day_2019))

# analyzed

# Вибір з вагами:
import random

colors = ["червоний", "зелений", "синій"]
weights = [10, 1, 1]  # задає weight для списку
chosen_color = random.choices(colors, weights, k=1)
print(chosen_color)

# analyzed

"""
Вимоги до завдання:

Параметри функції:
min - мінімальне можливе число у наборі (не менше 1).
max - максимальне можливе число у наборі (не більше 1000).
quantity - кількість чисел, які потрібно вибрати (значення між min і max).
Функція генерує вказану кількість унікальних чисел у заданому діапазоні.
Функція повертає список випадково вибраних, відсортованих чисел. Числа в наборі не повинні повторюватися. Якщо параметри не відповідають заданим обмеженням, функція повертає пустий список.

"""

import random


def get_numbers_ticket(min, max, quantity):
    if (
        min < 1
        or max > 1000
        or max < min
        or quantity < 1
        or quantity > 1000
        or quantity > max - min + 1
    ):
        print(f"Out of range")
        return list()
    else:
        ticket_list = set()
        while len(ticket_list) < quantity:
            ticket_list.add(random.randint(min, max))

        print(f"The range of number starts from: {min} to {max}")
        return ticket_list


lottery_numbers = get_numbers_ticket(1, 100, 9)
print("Ваші лотерейні числа:", lottery_numbers)
print(len(lottery_numbers))

# Done

import random
import time

start_time = time.perf_counter()


# Task #2
def get_numbers_ticket(min, max, quantity):
    if (
        min < 1
        or max > 1000
        or max < min
        or quantity < 1
        or quantity > 1000
        or quantity > max - min + 1
    ):
        print(f"Out of range")
        return list()
    # else:
    #     ticket_list = range(min, max+1)
    #     the_main_list = sorted(random.sample(ticket_list, quantity))
    #     #final_list = sorted(the_main_list)
    # return the_main_list
    # Nice one option :)
    # return sorted(random.sample(range(min, max+1), quantity))


lottery_numbers = get_numbers_ticket(1, 49, 6)
print("Ваші лотерейні числа:", lottery_numbers)

end_time = time.perf_counter()

execution_time = end_time - start_time
print(f"Час виконання: {execution_time} секунд")

# 0.0001981999957934022 секунд > Час виконання: 0.00016469997353851795 секунд
# Done


# Autotest task 1
from datetime import datetime


def string_to_date(date_string):
    datetime_object = datetime.strptime(date_string, "%Y.%m.%d")
    return datetime_object


def date_to_string(date):
    string_object = date.strftime("%Y-%m-%d")
    return string_object


"""
Якщо функція string_to_date отримала рядок 2020.01.01 то вона повинно повернути обєкт datatime: 2020-01-01. Поточний результат: : time data '2020.01.01' does not match format '%Y-%m-%d'

"""

print(string_to_date("2020.01.01"))

#  У Харкові відкривають у бомбосховищі школу для молодших школярів.
# Треба  обладнати три кімнати партами. Парта  - на дві людини.
# Програмі подається на вхід три числа (трьома input)  - кількість учнів в кожному
# класі. Програма має порахувати необхідну кількість парт загалом.


# first_class_people = int(input('Введіть кількість учнів першому классі:'))
# second_class_people = int(input('Введіть кількість учнів другому лассі:'))
# third_class_people = int(input('Введіть кількість учнів третьому классі:'))


# first_class_tables = first_class_people // 2 + first_class_people % 2
# second_class_tables = second_class_people // 2 + second_class_people % 2
# third_class_tables = third_class_people // 2 + third_class_people % 2

# print(f'В перший класс потрібно {first_class_tables} парт,В другий класс потрібно {second_class_tables} парт, В третій класс потрібно {third_class_tables} парт, всьго потрібно парт {first_class_tables + second_class_tables + third_class_tables }')

# Зчитайте дійсне число. Виведіть його першу цифру після крапки.

# number = ((89.12 % 1) * 10)
# print(int(number))

# Плюсами намалювати  такий трикутник
#   +
#   +++
#   +++++
#   +++++++
#   +++++++++

# for i in range(5):
#     i = "+" * 2
#     print(i)
# i = 5
# x = 1
# while i > 0:
#      print(' '*(i-1) + 'x'*(10-i*2+1))
#      i -= 1

# Done

# В рядку написан текст.
# Для кожного слова підрахуйте
# кілька разів воно зустрічалось в цьому тексті.

# text = '''
#         Little girl, little girl Why are you crying? Inside your restless soul your heart is dying Little one, little one Your soul is purging Of love and razor blades Your blood is surging Runaway From the river to the street And find yourself with your face in the gutter Your a stray for the salvation army There is no place like home When you got no place to go Little girl, little girl Your life is calling The charlatans and saints of your abandon Little one little one The sky is falling The lifeboat of deception is now sailing In the wake all the way No rhyme or reason Your bloodshot eyes Will show your heart of treason Little girl little girl You dirty liar You're just a junkie Preaching to the choir Runaway To your lost tranquility And find yourself with your face in the gutter Your a stray for the dregs of humanity There is no place like home When you got no place to go The traces of blood Always follow you home Like the Mascara tears From your getaway Your walking with blisters And running with shears So unholy. Sister of grace. Runaway From the river to the street And find yourself with your face in the gutter You're a stray for the salvation army There is no place like home When you got no place to go
#         '''
# text = text.replace(',',' ').replace('.', ' ').replace('!', ' ').replace('?', ' ').lower()
# word_counter = {}
# text_splt = text.split()
# for word in text_splt:
#     word_counter[word] = word_counter.get(word, 0) + 1
# # Перегорнули список
# word_counter_reversed = {}
# for key, value in word_counter.items():
#     word_counter_reversed[value] = word_counter_reversed.get(value, []) + [key]
# # Вивели відсортований список
# sorted_words = sorted(word_counter_reversed)
# for word in sorted_words:
#     print(word,word_counter_reversed[word])

# #Done


# Нам треба написати код, який обробляє URL пошукового запиту, щоб видобути параметри запиту та перетворити їх у формат, з яким легше працювати в Python.
# Перший шаг ми відділяємо параметри запросу
url_search = "<https://www.google.com/search?q=Cat+and+dog&ie=utf-8&oe=utf-8&aq=t>"
_, query = url_search.split("?")
print(query)
# дадаємо словник з ключ значеннями і розділяємо його
obj_query = {}
for el in query.split("&"):
    key, value = el.split("=")
    obj_query.update({key: value.replace("+", " ")})
print(obj_query)

# Analyzed
# Autocheck #2 module 3
from datetime import datetime


def string_to_date(date_string):
    return datetime.strptime(date_string, "%Y.%m.%d").date()


def prepare_user_list(user_data):
    for user in user_data:
        user["birthday"] = string_to_date(user["birthday"])
    return user_data


# done #analyzed

# Пригадаємо як звучить наше завдання. У межах вашої організації, ви відповідаєте за організацію привітань колег з днем народження. Щоб оптимізувати цей процес,
# вам потрібно створити функцію get_upcoming_birthdays, яка допоможе вам визначати, кого з колег потрібно привітати.
# Функція повинна повернути список всіх у кого день народження вперед на 7 днів включаючи поточний день.

from datetime import datetime, date, timedelta


def string_to_date(date_string):
    return datetime.strptime(date_string, "%Y.%m.%d").date()


def date_to_string(date):
    return date.strftime("%Y.%m.%d")


def prepare_user_list(user_data):
    prepared_list = []
    for user in user_data:
        prepared_list.append(
            {"name": user["name"], "birthday": string_to_date(user["birthday"])}
        )
    return prepared_list


def find_next_weekday(start_date, weekday):
    days_ahead = weekday - start_date.weekday()
    if days_ahead <= 0:
        days_ahead += 7
    return start_date + timedelta(days=days_ahead)


def adjust_for_weekend(birthday):
    if birthday.weekday() >= 5:
        return find_next_weekday(birthday, 0)
    return birthday  # повертає обект datetime.date


def get_upcoming_birthdays(users, days=7):
    upcoming_birthdays = []
    today = date.today()

    for user in users:
        birthday_this_year = user["birthday"].replace(year=today.year)
        if birthday_this_year < today:
            birthday_this_year = user["birthday"].replace(year=today.year + 1)

        """
        Додайте на цьому місці перевірку, чи не буде 
        припадати день народження вже наступного року.
        """

        if 0 <= (birthday_this_year - today).days <= days:
            if birthday_this_year.weekday() >= 5:
                birthday_this_year = find_next_weekday(birthday_this_year, 0)

            """ 
            Додайте перенесення дати привітання на наступний робочий день,
            якщо день народження припадає на вихідний. 
            """

            congratulation_date_str = date_to_string(birthday_this_year)
            upcoming_birthdays.append(
                {"name": user["name"], "congratulation_date": congratulation_date_str}
            )
    return upcoming_birthdays


# done # Saved for future projects


# Всі файли потрібно навмистно приводити до UTF - 8 такі правила...
# Відкриття текстового файлу з явним вказівкам UTF-8 кодування
with open("example.txt", "r", encoding="utf-8") as file:
    content = file.read()
    print(content)
# Analyzed


"""
Дан рядок. 
Розріжте його навпіл і переставте ці половинки містами.
Якщо довжина непарна, то перша частина буде більшою.

"""


# line = '12345'
# line_middle = round(len(line)//2) + len(line)%2
# first_half = line[:line_middle]
# second_half = line[line_middle:]
# reversed_line =  second_half + first_half

# print(reversed_line)


"""
Дан рядок.
НАйдіть в ньому другу букву "а". Виведіть індекс.
Якщо є тільки одна  - виведить "alone", якщо взагалі нема
виведіть None
"""
# def find_second_occurrence(s, char):
#     first_occurrence = s.find(char)
#     if first_occurrence == -1:
#         return None
#     second_occurrence = s.find(char, first_occurrence + 1)
#     return second_occurrence


# index_of_second_a = find_second_occurrence("banaaana", "a")
# print(index_of_second_a)
"""
У Джо Палуки товсті пальці, тому він завжди натискає клавішу "Caps Lock", коли насправді має намір натиснути клавішу "a". 
(Коли Джо намагається ввести якусь акцентовану версію "a", яка потребує більше натискань клавіш для створення акцентів, 
він більш обережний у присутності таких рафінованих символів ([Shift] + [a]) і буде натискати клавіші правильно). 
Обчисліть і виведіть результат введення Джо заданого тексту. 
Клавіша "Caps Lock" впливає лише на клавіші з літерами від "a" до "z", і не впливає на інші клавіші або символи. вважається, що клавіша "Caps Lock" спочатку вимкнена.
assert caps_lock("Why are you asking me that?") == "Why RE YOU sking me thT?"
assert caps_lock("Always wanted to visit Zambia.") == "AlwYS Wnted to visit ZMBI."
assert caps_lock("Aloha from Hawaii") == "Aloh FROM HwII"
"""

# def caps_lock(text):
#     formated_text = text.split('a')
#     for i in range(1, len(formated_text),2):
#         formated_text[i] = formated_text[i].upper()
#     print(''.join(formated_text))
#     return ''.join(formated_text)


# assert caps_lock("Why are you asking me that?") == "Why RE YOU sking me thT?"
# assert caps_lock("Always wanted to visit Zambia.") == "AlwYS Wnted to visit ZMBI."
# assert caps_lock("Aloha from Hawaii") == "Aloh FROM HwII"

"""
Як із рядка слов отримати словник де ключи та значення записані попарно.
Наприклад: "Hello Hi Bye Goodbye List Array"
{"Hello": "Hi", 
"Bye": "Goodbye", 
"List": "Array"}
"""
"""
У тебе є таблиця з усіма наявними товарами в магазині. Дані представлені у вигляді списку словників

Твоя місія - знайти ТОП найдорожчих товарів. Кількість товарів, які ми шукаємо, буде передано у першому аргументі, а самі дані щодо товарів будуть передані другим аргументом.

Вхідні дані: Число та список словників (int and list of dicts). Кожен словник має 2 ключі "name" та "price".

Вихідні дані: Такий, як і другий аргумент.

Приклади:

assert bigger_price(
    2,
    [
        {"name": "bread", "price": 100},
        {"name": "wine", "price": 138},
        {"name": "meat", "price": 15},
        {"name": "water", "price": 1},
    ],
) == [{"name": "wine", "price": 138}, {"name": "bread", "price": 100}]
assert bigger_price(
    1, [{"name": "pen", "price": 5}, {"name": "whiteboard", "price": 170}]
) == [{"name": "whiteboard", "price": 170}]
"""
# def sort_price(dict_:dict):
#     return -dict_['price'] #check tommorow

# def bigger_price(count:int , goods:list):
#     print(sorted(goods, key=sort_price)[:count])
#     return sorted(goods, key=sort_price)[:count]


# assert bigger_price(
#     2,
#     [
#         {"name": "bread", "price": 100},
#         {"name": "wine", "price": 138},
#         {"name": "meat", "price": 15},
#         {"name": "water", "price": 1},
#     ],
# ) == [{"name": "wine", "price": 138}, {"name": "bread", "price": 100}]
# assert bigger_price(
#     1, [{"name": "pen", "price": 5}, {"name": "whiteboard", "price": 170}]
# ) == [{"name": "whiteboard", "price": 170}]

"""
Тобі дано словник із акціями і їх цінами. Функція повинна повертати найдорожчу акцію.

Вхідні значення: Словник, у якому біржовий тікер (коротка назва) акції є ключем, а значенням є ціна цієї акції.

Вихідні значення: Біржовий тікер як рядок.

Приклади:

assert best_stock({"CAC": 10.0, "ATX": 390.2, "WIG": 1.2}) == "ATX"
assert best_stock({"CAC": 91.1, "ATX": 1.01, "TASI": 120.9}) == "TASI"

Передумови: Ціни є унікальними, тобто не повторюються.
"""


# def best_stock(stock):
#     print(sorted(stock, key=stock.get))
#     return sorted(stock, key=stock.get)[-1]


# assert best_stock({"CAC": 10.0, "ATX": 390.2, "WIG": 1.2}) == "ATX"
# assert best_stock({"CAC": 91.1, "ATX": 1.01, "TASI": 120.9}) == "TASI"

"""
Coin Change Problem
You are given an unlimited supply of coins of certain denominations and a total amount of money. 
Write a function that returns the number of distinct ways you can make the total amount using these coins. 
The order of coins does not matter.

Input:

coins: a list of integers representing the coin denominations available.
amount: an integer representing the total amount of money.
Output:

Return the number of ways you can make the amount using any number of coins from coins.
"""

# def count_ways(coins, amount):
#     cache = {}
#     def recursive_count(current_amount):
#         if current_amount in cache:
#             return cache[current_amount]
#         elif current_amount == 0:
#             return 1
#         elif current_amount < 0:
#             return 0

#         result = 0
#         for coin in coins:
#             result += recursive_count(current_amount - coin)

#         cache[current_amount] = result
#         return result
#     return recursive_count(amount)

# coins = [1, 3, 4]
# amount = 10
# print(count_ways(coins, amount))
"""
Ми створимо клас Pokemon, що ілюструє основні принципи об'єктно-орієнтованого програмування (ООП), а потім створимо об'єкт класу Pokemon - pikachu. 
Клас Pokemon буде містити атрибути: name, type, і health.

Для класу ми визначимо наступні методи:

attack (напад) - дозволяє покемону атакувати іншого покемона.
dodge (уклон) - дає можливість уникнути атаки.
evolve (еволюціонувати) - дозволяє покемону еволюціонувати в іншу форму.
"""


class Pokemon:
    def __init__(self, name, type, health):
        self.name = name
        self.type = type
        self.health = health

    def attack(self, other_pokemon):
        print(f"{self.name} attacks {other_pokemon.name}!")

    def dodge(self):
        print(f"{self.name} dodged the attack!")

    def evolve(self, new_form):
        print(f"{self.name} is evolving into {new_form}!")
        self.name = new_form


# Створення об'єкта Pikachu
pikachu = Pokemon("Pikachu", "Electric", 100)

# Використання методів
pikachu.attack(Pokemon("Charmander", "Fire", 100))
pikachu.dodge()
pikachu.evolve("Raichu")


"""
Taks polindrome problem: context - is a word a polindrome?
"""

# def is_palindrome(word: str) -> bool:
#     return word.lower() == word[::-1].lower()


# print(is_palindrome('radar'))  # True
# print(is_palindrome('hello'))  # False
# print(is_palindrome('level'))  # True
# print(is_palindrome('Level'))  # True


# # formated_word = word.lower()
# #     new_word = ''
# #     for i in formated_word[::-1]:
# #         new_word += i
# #     if new_word == formated_word:
# #         return True
# #     else:
# #         return False


"""
Booking a hotel room: context : find out if the number is available for booking.
"""

# def calculate_guests(request: str) -> int or str:
#     number_of_guests = ''
#     for char in request:
#         print(char)
#         if char.isnumeric():
#             number_of_guests += char
#         elif len(number_of_guests) != 0:
#             break

#     print(number_of_guests)
#     return 'not a number' if number_of_guests == '' or number_of_guests == '0' else int(number_of_guests)


# print(calculate_guests("I think 5 guests") == 5)
# print(calculate_guests("Big company of 15 dudes") == 15)
# print(calculate_guests("5") == 5)
# print(calculate_guests("alone") == "not a number")
# print(calculate_guests("0") == "not a number")
# print(calculate_guests("Hello, 9.75 people") == 9)
# print(calculate_guests("There will be 7 or 9 guys") == 7)
# print(calculate_guests("hello cat walks on my keyboard ksadjfhskaj12.34kasdfhsjk") == 12)

"""
Taks 3: check if the string is in alphabtick oreder or not :)
"""

# def is_alphabet(symbols:str) -> bool:
#     alphabet = "abcdefghijklmnopqrstuvwxyz"
#     return  symbols.lower() in alphabet


# print(is_alphabet("abc")) #isTrue
# print(is_alphabet("aBc")) #isTrue
# print(is_alphabet("abd")) #isFalse - після b йде c
# print(is_alphabet("a")) #isTrue
# print(is_alphabet("abcdefghjiklmnopqrstuvwxyz")) #isFalse - #j йде після i
# print(is_alphabet("tuvwxyz")) #isTrue
# print(is_alphabet("XYZ")) #isTrue


# formated_str = symbols.lower()
# alphabet = "abcdefghijklmnopqrstuvwxyz"
# if formated_str in alphabet:
#     return True
# else:
#     return False

"""
Codeland Username Validation
Have the function CodelandUsernameValidation(str) take the str parameter being passed and determine if the string is a valid username according to the following rules:

1. The username is between 4 and 25 characters.
2. It must start with a letter.
3. It can only contain letters, numbers, and the underscore character.
4. It cannot end with an underscore character.

If the username is valid then your program should return the string true, otherwise return the string false.

Input: "aa_"
Output: false
Input: "u__hello_world123"
Output: true
"""

# Chat GPT attempt
import re


def CodelandUsernameValidation(strParam):
    # Define the pattern to match valid usernames
    pattern = re.compile(
        r"^[a-zA-Z][a-zA-Z0-9_]{2,24}$"
    )  # Username length: 4-25 characters

    # Check if the string length is within the valid range
    if len(strParam) < 4 or len(strParam) > 25:
        return False

    # Check if the string matches the pattern
    if not pattern.match(strParam):
        return False

    # Check if the username ends with an underscore
    if strParam.endswith("_"):
        return False

    return True


# That Works


# My attemp

# def CodelandUsernameValidation(strParam):
#         numbers = '1234567890'
#         underscores = '_'
#         pattern = re.compile(r'^[a-zA-Z0-9_]+$')
#         if len(strParam) < 4 or len(strParam) > 25:
#                 return False
#         elif strParam.startswith(numbers) or strParam.startswith(underscores):
#                 return False
#         elif pattern.match(strParam):
#                 return False
#         elif strParam.endswith(underscores):
#                 return False
#         else:
#                 return True


# keep this function call here
print(CodelandUsernameValidation("u__hello_world123"))

"""
Dict task: 1
"""


def user_update(user_data: list) -> None:
    for user in user_data:
        user["full_name"] = user["first_name"] + " " + user["last_name"]
        print(user["full_name"])


users = [
    {
        "first_name": "Jack",
        "last_name": "Holy",
    },
    {
        "first_name": "Mike",
        "last_name": "Adams",
    },
]

print(user_update(users))
print(users)

"""
Dict task: 2 
"""


def user_update(user_data: list) -> None:
    for user in user_data:
        user["first_name"] = user["full_name"].split(" ")[0]


users = [
    {"last_name": "Holy", "full_name": "Jack Holy"},
    {"last_name": "Adams", "full_name": "Mike Adams"},
    {"last_name": "Adams", "full_name": "Mikessss Adams"},
]

print(user_update(users))
print(users)

"""
Dict task: 3 
"""


def user_update(user_data: list) -> None:
    for user in user_data:
        if user["status"] == "disabled":
            user.pop("country")


users = [
    {"name": "Emma", "status": "active", "country": "Ukraine"},
    {"name": "Avram", "status": "disabled", "country": "Poland"},
    {"name": "Avram", "status": "active", "country": "Poland"},
    {"name": "Avram", "status": "disabled", "country": "Poland"},
]

print(user_update(users))
print(users)

"""
Dict task: 4 
"""


def robot_version_check(robot_data: list, version: int) -> None:
    index_list = [
        i for i, item in enumerate(robot_data) if item["core_version"] < version
    ]
    # for i, item in enumerate(robot_data): #good function make a note
    #     if item["core_version"] < version:
    #         index_list.append(i)
    return index_list


robots = [
    {"core_version": 9},
    {"core_version": 13},
    {"core_version": 16},
    {"core_version": 9},
    {"core_version": 14},
]

print(robot_version_check(robots, 10))  # [0, 3])
print(robot_version_check(robots, 14))  # [0, 1, 3])
print(robot_version_check(robots, 8))  # [])
print(robot_version_check(robots, 18))  # [0, 1, 2, 3, 4])

"""
Dict task with lambda: 5 
"""


def calculator(number1: int, number2: int, operator: str):
    operations = {
        "+": lambda x, y: x + y,
        "-": lambda x, y: x - y,
        "*": lambda x, y: x * y,
        "/": lambda x, y: x / y,
    }
    return operations[operator](number1, number2)


print(calculator(1, 2, "+"))

"""
Dict task with tuple: 6 
"""


def create_dino_archive(name: list, lenght: list, diets: list):
    dino_list = zip(name, lenght, diets)  # remember zip always return tuple!
    return list(dino_list)


dino_name = ["Tyrannosaurus", "Velociraptor", "Triceratops", "Saltopus"]
dino_lenghts = [12, 2, 9, 1]
dino_diets = ["carnivorous", "carnivorous", "herbivorous", "herbivorous"]

print(create_dino_archive(dino_name, dino_lenghts, dino_diets))
# [("Tyrannosaurus", 12, "carnivorous"), ("Velociraptor", 2, "carnivorous"), ("Triceratops", 9, "herbivorous"), ("Saltopus", 1, "herbivorous")]


"""
Dict comp task with tuple: 6 
"""


def norm_data(data: list):
    formated_data = {
        user[0]: {"name": user[1], "login": user[2], "Password": user[3]}
        for user in data
    }
    print(formated_data)


users = [
    (12, "Maxim", "maxim@example.com", "UBg11eub42hge"),
    (13, "Dmitro", "dmitro@example.com", "sdTioT36723fw"),
    (14, "Roman", "roman@example.com", "hbFEkj34NggE2"),
    (15, "Ivan", "ivan@example.com", "sdTioT36723fw"),
]

print(norm_data(users))


"""
Почнемо з простого завдання - поєдинку один на один. Вам потрібно створити клас Warrior, 
екземпляри якого матимуть 2 параметри – health (дорівнює 50 балам) і attack (дорівнює 5 балам), 
а також 1 властивість – is_alive, яка може бути True (якщо здоров’я воїна > 0). ) або False (в іншому випадку). 
Крім того, ви повинні створити другий тип одиниць – Knight, який має бути підкласом Warrior, але мати підвищену атаку – 7. 
Також вам потрібно створити функцію fight(), яка ініціюватиме двобій між 2 бійцями та визначатиме найсильніший з них. 
Поєдинок відбувається за таким принципом:
Кожного ходу перший воїн буде вдаряти по другому, і цей другий втрачатиме своє здоров'я в тій самій величині, 
що і атака першого воїна. 
Після цього, якщо він ще живий, другий воїн зробить те ж саме з першим.
Поєдинок закінчується смертю одного з них. 
Якщо перший воїн ще живий (і, отже, іншого більше немає), функція має повернути True, False в іншому випадку.
"""
from collections import UserList


class Warrior:
    def __init__(self, health=50, attack=5) -> None:
        self.health = health
        self.attack = attack

    @property
    def is_alive(self):
        return self.health > 0

    def damage(self, attack):
        self.health -= attack

    def hit(self, unit):
        unit.damage(self.attack)


class Knight(Warrior):
    def __init__(self, health=50, attack=7) -> None:
        super().__init__(health=health, attack=attack)


class Defender(Warrior):
    def __init__(self, health=60, attack=3, defence=2) -> None:
        super().__init__(health=health, attack=attack)
        self.defence = defence

    def damage(self, attack):
        if attack > self.defence:
            self.health -= attack - self.defence


class Army(UserList):
    def add_units(self, warriors_type: Warrior, amount: int):
        for _ in range(amount):
            self.data.append(warriors_type())  # создаём 20 экземпляров класса

    @property
    def is_exist(self):
        return bool(self.data) > 0


class Battle:

    def fight(self, first_army: Army, second_army: Army):
        while first_army.is_exist and second_army.is_exist:
            if fight(first_army[0], second_army[0]):
                second_army.pop(0)
            else:
                first_army.pop(0)
        return first_army.is_exist


def fight(fighter1: Warrior, fighter2: Warrior):
    while fighter1.is_alive and fighter2.is_alive:
        fighter1.hit(fighter2)
        # fighter2.health -= fighter1.attack
        if fighter2.is_alive:
            fighter2.hit(fighter1)
    return fighter1.is_alive


if __name__ == "__main__":
    # These "asserts" using only for self-checking and not necessary for auto-testing

    # fight tests
    chuck = Warrior()
    bruce = Warrior()
    carl = Knight()
    dave = Warrior()
    mark = Warrior()
    bob = Defender()
    mike = Knight()
    rog = Warrior()
    lancelot = Defender()

    assert fight(chuck, bruce) == True
    assert fight(dave, carl) == False
    assert chuck.is_alive == True
    assert bruce.is_alive == False
    assert carl.is_alive == True
    assert dave.is_alive == False
    assert fight(carl, mark) == False
    assert carl.is_alive == False
    assert fight(bob, mike) == False
    assert fight(lancelot, rog) == True

    # battle tests
    my_army = Army()
    my_army.add_units(Defender, 1)

    enemy_army = Army()
    enemy_army.add_units(Warrior, 2)

    army_3 = Army()
    army_3.add_units(Warrior, 1)
    army_3.add_units(Defender, 1)

    army_4 = Army()
    army_4.add_units(Warrior, 2)

    battle = Battle()

    assert battle.fight(my_army, enemy_army) == False
    assert battle.fight(army_3, army_4) == True
    print("Coding complete? Let's try tests!")
"""
Дано текст і потрібно знайти його перше слово.

Даний текст містить англійські букви та пробіли.
На початку та у кінці пробілів немає.
"""


def first_word(text: str) -> str:
    word = ""
    for leter in text:
        if leter == " ":
            break
        else:
            word += leter

    return word


# alterative that is faster because of method using
def first_word_2(text):
    index = text.find(" ")
    return text[:index] if index != -1 else text


print("Example:")
print(first_word("Hello world"))

# These "asserts" are used for self-checking
assert first_word("Hello world") == "Hello"
assert first_word("a word") == "a"
assert first_word("greeting from CheckiO Planet") == "greeting"
assert first_word("hi") == "hi"

print("The mission is done! Click 'Check Solution' to earn rewards!")


"""
Ця функція повинна приймати на вхід рядок і повертати кількість голосних (a, e, i, o, u) у рядку. Функція повинна бути нечутливою до регістру.
"""


def count_vowels(text: str) -> int:
    counter = 0
    for char in text.lower():
        counter += (
            char in "aeiou"
        )  # in this case it returns True or False and Python can interpritate it as 1 (True) or 0 (False), so we can do math with that.
    return counter


print("Example:")
print(count_vowels("Hello"))


"""
Ця функція повинна приймати на вхід рядок без розділових знаків і повертати найдовше слово у рядку. 
Якщо у рядку є декілька слів однакової довжини, поверніть перше, яке з'явиться на екрані.
"""


# My option
def longest_word(sentence: str) -> str:
    formated_text = sentence.split(" ")
    longest_word = ""
    print(formated_text)
    for word in formated_text:
        if len(word) > len(longest_word):
            longest_word = word

    return longest_word


# alterantive "clear"
def longest_word(sentence: str) -> str:
    return max(sentence.split(), key=len, default="")


# alterantive "creative"
def longest_word(sentence: str) -> str:
    sentence_sorted = sorted(sentence.split(" "), key=len, reverse=True)
    return sentence_sorted[0]


"""
Ми маємо список логічних (булевих) значень. Давай перевіримо, чи більшість елементів є True.

Деякі випадки, варті згадки: 1) порожній список повинен повертати False; 2) якщо однакова кількість True і False, функція повинна повертати False.
"""


def is_majority(items: list[bool]) -> bool:
    counter = 0
    for element in items:
        if element:
            counter += 1
        else:
            counter -= 1

    if counter > 0:
        return True
    elif counter == 0:
        return False
    else:
        return False


# Alternative solutions

# def is_majority(items: list) -> bool:
#     return sum(items) > len(items) / 2


"""
Надано масив з позитивними числами і число N. 
Ви повинні знайти N-ну ступінь елемента в масиві з індексом N. 
Якщо N за межами масива, тодi повернути -1. 
"""

print("Example:")
print(is_majority([True, True, False, True, False]))

# These "asserts" are used for self-checking
assert is_majority([True, True, False, True, False]) == True
assert is_majority([True, True, False]) == True
assert is_majority([True, True, False, False]) == False
assert is_majority([True, True, False, False, False]) == False
assert is_majority([False]) == False
assert is_majority([True]) == True
assert is_majority([]) == False

print("The mission is done! Click 'Check Solution' to earn rewards!")


def index_power(ar: list[int], n: int) -> int:
    if n > len(ar):
        return -1
    else:
        for idx, elem in enumerate(ar):
            if idx == n:
                return elem**n


# Alternative solution
def index_power(array, n):
    try:
        return array[n] ** n
    except IndexError:
        return -1


print("Example:")
print(index_power([1, 2, 3], 2))

# These "asserts" are used for self-checking
assert index_power([1, 2, 3, 4], 2) == 9
assert index_power([1, 3, 10, 100], 3) == 1000000
assert index_power([0, 1], 0) == 1
assert index_power([1, 2], 3) == -1

print("The mission is done! Click 'Check Solution' to earn rewards!")

"""
Задано масив цілих чисел. Потрібно знайти суму елементів з парними індексами (0-й, 2-й, 4-й і т.д.), а потім перемножити цю суму і останній елемент вихідного масиву. 
Не забудьте, що перший елемент масиву має індекс 0.
"""


def checkio(array: list[int]) -> int:
    data = []
    if len(array) == 0:
        return 0
    else:
        for idx, elem in enumerate(array):
            if idx % 2 == 0:
                data.append(elem)

    return sum(data) * array[-1]


# alternative
# if len(array) == 0: return 0
#     return sum(array[0::2]) * array[-1]


print("Example:")
print(checkio([0, 1, 2, 3, 4, 5]))

# These "asserts" are used for self-checking
assert checkio([0, 1, 2, 3, 4, 5]) == 30
assert checkio([1, 3, 5]) == 30
assert checkio([6]) == 36
assert checkio([]) == 0

# print("The mission is done! Click 'Check Solution' to earn rewards!")


"""
"Іноді, нулі нагадують дуже смачні пончики. І кожного разу, коли ми доїдаємо пончик, нам хочеться ще один, а потім ще один, а потім ще..."

Тобі дано список з цілими числами. Твоя задача в цій місії - продублювати (..., 🍩, ... --> ..., 🍩, 🍩, ...) всі нулі (думай при цьому про пончики ;-P) 
та повернути результат у вигляді ітеративного об'єкта. Поглянемо на приклад:
"""


def duplicate_zeros(donuts: list[int]) -> Iterable[int]:
    i = len(donuts) - 1
    while i >= 0:
        if donuts[i] == 0:
            donuts.insert(i + 1, 0)
        i -= 1
    return donuts


print("Example:")
print(list(duplicate_zeros([1, 0, 2, 3, 0, 4, 5, 0])))

# These "asserts" are used for self-checking
assert list(duplicate_zeros([1, 0, 2, 3, 0, 4, 5, 0])) == [
    1,
    0,
    0,
    2,
    3,
    0,
    0,
    4,
    5,
    0,
    0,
]
assert list(duplicate_zeros([0, 0, 0, 0])) == [0, 0, 0, 0, 0, 0, 0, 0]
assert list(duplicate_zeros([100, 10, 0, 101, 1000])) == [100, 10, 0, 0, 101, 1000]

print("The mission is done! Click 'Check Solution' to earn rewards!")

"""
Медіана – це числове значення, яке ділить відсортований список чисел на більшу і меншу половини. 
У відсортованому списку з непарним числом елементів медіана – це число в середині списку. 
Для списку з парним числом елементів, де немає жодного елемента точно посередині, медіана – це середнє значення двох чисел, які знаходяться в середині списку. 
В цій задачі заданий непустий список натуральних чисел. Вам потрібно знайти медіану даного списку.

Ідея у тому, щоб відсортувати початковий список і, залежно від його довжини, знайти один або два елементи посередині за їх індексами. 
Тоді повернути один або середнє з двох значень.
"""


def checkio(data: list[int]) -> int | float:
    item = sorted(data)
    ind, rem = divmod(len(item), 2)
    print(ind, rem)
    median = item[ind] if rem == 1 else (item[ind - 1] + item[ind]) / 2

    return median


print("Example:")
print(checkio([1, 2, 3, 4, 5]))


"""
Дана послідовність рядків. Ти маєш об'єднати ці рядки в блок тексту, розділивши їх комами. 
В якості жарта над праворукими роботами, ти повинен замінити всі входження слова "right" на слова "left", навіть якщо це частина іншого слова. 
Всі рядки дані в нижньому регістрі.
"""


def left_join(phrases: tuple[str]) -> str:
    new_phrases = ",".join(phrases).lower()
    return new_phrases.replace("right", "left")


print("Example:")
print(left_join(("left", "right", "left", "stop")))


#######LEETCODE 509########
class Solution:
    def fib(self, n: int) -> int:

        # if n == 1:
        #     return 1

        # if n == 0:
        #     return 0

        # return self.fib(n-1) + self.fib(n-2)
        # COOL :)
        ans = [0, 1]

        for i in range(2, n + 1):
            ans.append(ans[i - 1] + ans[i - 2])

        return ans[n]


fib1 = Solution()

print(fib1.fib(100))


###### LEETCODE twoSum problem ##########
def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        print(f"is left index = {left}")
        print(f"is right index = {right}")
        curr_sum = (
            numbers[left] + numbers[right]
        )  # here we add two numbers based on their idexes
        if curr_sum == target:
            return [left + 1, right + 1]
        elif curr_sum < target:
            left += 1  # we move index here
        else:
            right -= 1  # we move index here


print(twoSum([1, 2, 3, 4, 5, 6, 7], 100))

# numbers = [1,2]
# curr_sum = numbers[0] + numbers[1]
# print(curr_sum)


# to get the full control of index we need assing this to variable and work with it in case of math operations


"""
Є якісь данні, як приклад 'AAAAABBbCCCCC' повернтуи массив унікальних значень без повторювань - [A,B,b,C]
"""


def solution(data) -> list:
    result = []
    last_element = None

    for element in data:
        if element != last_element:
            result.append(element)
            last_element = element

    return result


print(solution("AAAAABBbCCCCC"))
print(solution([1, 1, 1, 2, 3, 4, 5, 5, 5]))
